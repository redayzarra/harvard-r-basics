# Think of data frames as data tables:
#   - Rows are like observations
#   - Columns are like different variables
# Data frames are useful for data sets because we can combine different types into one single object
library(dslabs) # Importing the dslabs library
data(murders) # Loading the murders dataset
class(murders) # Then tell us the class of the murders data frame
# The function str, stands for structure, it shows us the structure of the object
str(murders) # Gives us the structural info on the object, like that its a data frame with 51 observations and 5 variables
head(murders) # Gives us the first six lines of the data frame using the head function
# To access different variables or columns, we must use the dollar sign symbol, or the accessor -> $
# The order of the entries from the accessor ($) preserves the orders of the rows from our data table
# The object produced from the accessor, is a vector or an array
murders$population # Gives us the column associated with the population label, given to us by str
names(murders) # Gives us the names of the five columns or variables, we can use accessor($) to access those columns
pop <- murders$population # Assigns the variable pop to the column labeled population
length(pop) # Gives us the length of the variable pop which is 51
class(pop) # Tells us the class of pop which is a numeric because it stores numbers
# Character vectors are distinguished from variables and character strings from "quotes"
# All entries in a character vector need to be characters
b <- 1
b # Returns the number 1
b <- "b"
b # Now it returns the character "b" not the variable
class(murders$state) # Returns character because the state column has all character strings for values
# Logical vectors must either true or false
x <- 3 == 2 # We are asking "is 3 equal to 2?" with the relational operator(==) (which is FALSE) and assigning that value to x
x
class(x) # Tells us that the class of x is a logical, which is correct because x is FALSE
class(murders$region)
# Variables can have different types. The 'class' function can help us determine the type of an object.
a <- 2
class(a) # The result confirms that a is numeric
class(ls) # The result confirms that ls is a function
# The most common way of storing data sets is with data frames:
# Think of data frames as data tables:
#   - Rows are like observations
#   - Columns are like different variables
# Data frames are useful for data sets because we can combine different types into one single object
library(dslabs) # Importing the dslabs library
data(murders) # Loading the murders dataset
class(murders) # Then tell us the class of the murders data frame
# The function str, stands for structure, it shows us the structure of the object
str(murders) # Gives us the structural info on the object, like that its a data frame with 51 observations and 5 variables
head(murders) # Gives us the first six lines of the data frame using the head function
# To access different variables or columns, we must use the dollar sign symbol, or the accessor -> $
# The order of the entries from the accessor ($) preserves the orders of the rows from our data table
# The object produced from the accessor, is a vector or an array
murders$population # Gives us the column associated with the population label, given to us by str
names(murders) # Gives us the names of the five columns or variables, we can use accessor($) to access those columns
pop <- murders$population # Assigns the variable pop to the column labeled population
length(pop) # Gives us the length of the variable pop which is 51
class(pop) # Tells us the class of pop which is a numeric because it stores numbers
# Character vectors are distinguished from variables and character strings from "quotes"
# All entries in a character vector need to be characters
b <- 1
b # Returns the number 1
b <- "b"
b # Now it returns the character "b" not the variable
class(murders$state) # Returns character because the state column has all character strings for values
# Logical vectors must either true or false
x <- 3 == 2 # We are asking "is 3 equal to 2?" with the relational operator(==) (which is FALSE) and assigning that value to x
x
class(x) # Tells us that the class of x is a logical, which is correct because x is FALSE
# Factors are for storing categorical data which is when data is divided into certain categories, each state has its own region
class(murders$region) # Tells us that the column region contains factors, there are four factors
levels(murders$region)
a <- 2
b <- -1
c <- -4
(-b + sqrt(b^2 - 4*a*c)) / (2*a)
(-b - sqrt(b^2 - 4*a*c)) / (2*a)
log(1024, base = 4)
# Question 3a
library(dslabs)
data("movielens")
force(movielens)
data(movielens)
force(movielens)
View(movielens)
data("movielens")
str(movielens)
class(movielens$title)
class(movielens$genres)
nlevels(movielens$genres)
# There are many ways to create vectors, for example the function c which stands for concatenate
codes <- c(380, 124, 818)
country <- c("italy", "canada", "egypt")
country <- c("italy", "canada", "egypt") # Defining an object called country that stores the character strings for country names
codes2 <- c(italy=380, canada=124, egypt=818)
codes2
class(codes)
class(country)
class(codes2)
codes2 <- c(italy=380, canada="124", egypt=818) #Codes2 stores numeric objects that have values assigned to them
codes2
class(codes2) # The class of codes2 is
codes2 <- c(italy=380, canada=124, egypt=818) #Codes2 stores numeric objects that have values assigned to them
class(codes2) # The class of codes2 is
codes3 <- c("italy"=380, "canada"=124, "egypt"=818)
codes3
class(codes3)
# Vectors are the most basic ways to store data in R. Complex datasets can be broken down into vectors.
# For example, in the murders data frame each column can be broken down into a vector.
# There are many ways to create vectors, for example the function c which stands for concatenate
codes <- c(380, 124, 818) # Defining an object called codes with 3 numeric value for country codes
class(codes)
country <- c("italy", "canada", "egypt") # Defining an object called country that stores the character strings for country names
class(country)
codes2 <- c(italy=380, canada=124, egypt=818) # Codes2 stores numeric objects that have values assigned to them
codes2
class(codes2) # The class of codes2 is numeric because the objects inside store numeric values
codes3 <- c("italy"=380, "canada"=124, "egypt"=818) # Produces the same result as the code above
codes3
class(codes3)
# The names function can be used to assign names to the entries of vectors
codes <- c(380, 124, 818)
country <- c("italy", "canada", "egypt")
names(codes) <- country # Assigns the entries of codes, so 380, 124, 818, to the countries stored in the object country
codes
seq(1, 10) # Writes the numbers 1 through 10
seq(1, 10, 2)
1:10
codes[2]
codes(c(1,3)) #
codes(c(1,3)) # A multi-entry vector allows us to access multiple indices at once, we are basically creating
codes <- c(380, 124, 818)
country <- c("italy", "canada", "egypt")
names(codes) <- country # Assigns the entries of codes, so 380, 124, 818, to the countries stored in the object country
codes
codes(c(1,3)) # A multi-entry vector allows us to access multiple indices at once, we are basically creating
codes[c(1,3)] # A multi-entry vector allows us to access multiple indices at once, we are basically creating
codes[c(1,3)] # A multi-entry vector allows us to access multiple indices at once, we're creating vector storing 1 and 3 and accessing with that
codes[1:2] # Sequences can be used to access specific parts of vectors, in this case indices 1 to 2 in vector codes
codes["canada"]
codes["canada"] # Access entries with the names if you know the names of the entry
codes[c("egypt", "italy")]
x <- c(1, "canda", 3)
class(x) # We should expect to see an error here, because the vector isn't numeric or character
y <- 1:5
y
as.character(y) # Can turn numbers into characters, in this case the
y
z
enerates number 1 through 5
y <- 1:5 # Generates number 1 through 5
z <- as.character(y) # Can turn numbers into characters, creates a copy of the numeric vector y with character strings from 1 to 5
z
ls
clear
cls
# When an entry does not match the expected, R tries to guess what we meant before showing an error.
x <- c(1, "canda", 3)
class(x) # We should expect to see an error here, because the vector isn't numeric or character, but we get character
x # R has automatically converted the numbers we assigned into character strings. R coerced the data into character strings.
# There are many functions to force a specific data coercion
y <- 1:5 # Generates number 1 through 5
z <- as.character(y) # Can turn numbers into characters, creates a copy of the numeric vector y with character strings from 1 to 5
z
a
a <- as.numeric(z) # Can turn characters back into numbers
a
a <- c("1", "b", "3") # Contains character strings of numbers and letters
b <- as.numeric(a) # Converts them back into numbers but fails to do so for the letter b because it's not a number
b
library(dslabs)
data("murders")
data(murders)
library(dslabs)
data(murders)
force(murders)
x <- C(31, 4, 15, 92, 65)
x <- C(31, 4, 15, 92, 65)
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
ls
rm(list = ls())
x <- C(31, 4, 15, 92, 65)
x
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
rm(list = ls())
# Sorting allows us to rank values in a specific way
library(dslabs)
data(murders)
sort(murders$total) # The sort function sorts a vector in increasing order, but gives no information about the states
# To sort in a way where we also get information about the other variables, we can use the order function
order(murders$total) # Returns the indices that sort the vector
x <- C(31, 4, 15, 92, 65)
new <- C(31, 4, 15, 92, 65)
# To sort in a way where we also get information about the other variables, we can use the order function
x <- 3
x <- c(31, 4, 15, 92, 65)
x
sort(x)
order(x) # Returns the indices that sort the vector
index <- order(x) # Returns the indices to sort that vector, meaning you can apply those indices anywhere to put in order
index
x[index]
indices <- order(murders$total)
murders$state[indices]
murders$abb[indices]
max(murders$total)
murders$state[murdermax]
max(murders$total) # Gives us the largest value in the vector
murdermax <- which.max(murders$total) # Gives us the index of the largest value in the vector
murders$state[murdermax]
min(murders$total)
indexmin <- which.min(murders$total)
murders$state[indexmin]
x <- c(31, 4, 15, 92, 65)
x
rank(x)
